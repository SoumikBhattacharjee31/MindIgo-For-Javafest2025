from fastapi import APIRouter, Header, BackgroundTasks, HTTPException, status
from fastapi.responses import StreamingResponse
from app.dto import APIResponseClass, ChatRequest, ChatResponse, MessageHistoryRequest, MessageHistoryResponse, SessionResponse
from app.service import GeminiChatService 
from typing import Annotated
import json
import asyncio

from app.config import get_logger

router = APIRouter()
chat_service = GeminiChatService()
logger = get_logger(__name__)


def log_safety_alert(user_id: str, safety_alert: dict):
    """Background task to log safety alerts"""
    if safety_alert.get("level") in ["warning", "crisis"]:
        logger.warning(f"ðŸš¨ SAFETY ALERT - User {user_id}: {safety_alert}")


def validate_headers(user_id: str = None, user_name: str = None):
    """Validate required headers"""
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="X-User-Id header is required"
        )
    if not user_name:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="X-User-Name header is required"
        )
    if not user_id.isdigit():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="X-User-Id must be a valid integer"
        )
    return int(user_id), user_name


@router.get("/health")
def health_check() -> APIResponseClass:
    """Health check endpoint"""
    return APIResponseClass(
        success=True, 
        message="Mental Health Service Active", 
        data={"status": "healthy", "service": "genai-service"}
    )


@router.post("/session/new")
def create_new_session(
    user_id: Annotated[str | None, Header(alias="X-User-Id")] = None,
    user_name: Annotated[str | None, Header(alias="X-User-Name")] = None
) -> APIResponseClass:
    """Create a new chat session"""
    try:
        validated_user_id, validated_user_name = validate_headers(user_id, user_name)
        
        session_id = chat_service.provide_session_to_user(validated_user_id, validated_user_name)
        
        if not session_id:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to create session"
            )
        
        return APIResponseClass(
            success=True, 
            message="Session created successfully", 
            data={"session_id": session_id}
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error creating session for user {user_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error while creating session"
        )


@router.get("/session/{session_id}")
def get_session_history(
    session_id: str,
    page: int = 1,
    per_page: int = 20,
    user_id: Annotated[str | None, Header(alias="X-User-Id")] = None,
    user_name: Annotated[str | None, Header(alias="X-User-Name")] = None
) -> APIResponseClass:
    """Get session message history with pagination"""
    try:
        validate_headers(user_id, user_name)
        
        if not session_id:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Session ID is required"
            )
        
        if page < 1 or per_page < 1 or per_page > 100:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid pagination parameters. Page must be >= 1, per_page must be 1-100"
            )
        
        # Check if session exists
        session_info = chat_service.get_session(session_id)
        if not session_info:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Session not found"
            )
        
        # Get message history
        history_data = chat_service.get_message_history(session_id, page, per_page)
        
        return APIResponseClass(
            success=True,
            message="Session history retrieved successfully",
            data=MessageHistoryResponse(**history_data)
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting session history for {session_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error while retrieving session history"
        )


@router.post("/chat")
def chat_endpoint(
    request: ChatRequest, 
    background_tasks: BackgroundTasks,
    user_id: Annotated[str | None, Header(alias="X-User-Id")] = None,
    user_name: Annotated[str | None, Header(alias="X-User-Name")] = None
) -> APIResponseClass:    
    """Non-streaming chat endpoint"""
    try:
        validated_user_id, validated_user_name = validate_headers(user_id, user_name)
        
        if not request.prompt or not request.prompt.strip():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Message prompt is required and cannot be empty"
            )
        
        if not request.session_id:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Session ID is required"
            )

        response = chat_service.chat(
            message=request.prompt.strip(), 
            user_id=validated_user_id,
            user_name=validated_user_name,
            session_id=request.session_id,
        )
        
        # Log safety alerts in background
        if response.get("safety_alert") and response["safety_alert"].get("level") in ["warning", "crisis"]:
            background_tasks.add_task(log_safety_alert, user_id, response["safety_alert"])
        
        return APIResponseClass(
            success=True, 
            message="Response generated successfully", 
            data=ChatResponse(
                res=response["message"], 
                recommendations=response.get("recommendations", []),
                escalate=response.get("escalate", False),
                safety_alert=response.get("safety_alert", {}),
                session_id=response["session_id"]
            )
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error in chat for user {user_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error while processing chat request"
        )


@router.post("/chat/stream")
async def chat_stream_endpoint(
    request: ChatRequest, 
    background_tasks: BackgroundTasks,
    user_id: Annotated[str | None, Header(alias="X-User-Id")] = None,
    user_name: Annotated[str | None, Header(alias="X-User-Name")] = None
):
    """Streaming chat endpoint - sends message first, then metadata"""
    try:
        validated_user_id, validated_user_name = validate_headers(user_id, user_name)
        
        if not request.prompt or not request.prompt.strip():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Message prompt is required and cannot be empty"
            )
        
        if not request.session_id:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Session ID is required"
            )

        async def stream_generator():
            try:
                # Store message data for metadata
                message_data = {}
                
                # First, stream the text response
                async for chunk in chat_service.chat_stream(
                    message=request.prompt.strip(), 
                    user_id=validated_user_id,
                    user_name=validated_user_name,
                    session_id=request.session_id
                ):
                    yield f"data: {json.dumps({'type': 'text', 'content': chunk})}\n\n"
                
                # Wait a moment for processing to complete
                await asyncio.sleep(0.1)
                
                # Get the latest message metadata from the database
                try:
                    recent_messages = chat_service.get_recent_messages(request.session_id, count=1)
                    if recent_messages:
                        latest_message = recent_messages[0]
                        metadata = latest_message.get('metadata', {})
                        
                        # Send recommendations if available
                        recommendations = metadata.get('recommendations', [])
                        if recommendations:
                            yield f"data: {json.dumps({'type': 'recommendations', 'content': recommendations})}\n\n"
                        
                        # Send safety alert if present
                        safety_alert = metadata.get('safety_alert', {})
                        if safety_alert and safety_alert.get('level') != 'none':
                            yield f"data: {json.dumps({'type': 'safety_alert', 'content': safety_alert})}\n\n"
                            
                            # Log safety alerts in background
                            if safety_alert.get("level") in ["warning", "crisis"]:
                                background_tasks.add_task(log_safety_alert, user_id, safety_alert)
                        
                        # Send escalation flag
                        escalate = metadata.get('escalate', False)
                        if escalate:
                            yield f"data: {json.dumps({'type': 'escalate', 'content': True})}\n\n"
                        
                        # Send mood if available
                        mood = metadata.get('mood')
                        if mood:
                            yield f"data: {json.dumps({'type': 'mood', 'content': mood})}\n\n"
                        
                        # Send session info
                        yield f"data: {json.dumps({'type': 'session_id', 'content': request.session_id})}\n\n"
                        
                except Exception as meta_error:
                    logger.error(f"Error getting metadata: {str(meta_error)}")
                
                # Send completion marker
                yield f"data: {json.dumps({'type': 'complete', 'content': 'done'})}\n\n"
                
            except Exception as e:
                logger.error(f"Streaming error for user {user_id}: {str(e)}")
                yield f"data: {json.dumps({'type': 'error', 'content': 'An error occurred while processing your request'})}\n\n"
        
        return StreamingResponse(
            stream_generator(), 
            media_type="text/plain",
            headers={
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
                "Content-Type": "text/plain; charset=utf-8"
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error setting up stream for user {user_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error while setting up chat stream"
        )